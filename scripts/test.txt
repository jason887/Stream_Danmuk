<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸»æ’­æè¯å™¨æ§åˆ¶ç«¯</title>
    <style>
        body { font-family: sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        .container { max-width: 800px; margin: auto; background-color: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        h1, h2, h3 { color: #333; margin-top: 0.8em; margin-bottom: 0.4em; }
        .control-panel, .script-info, .current-line-display, .status-messages, .navigation-controls, .roast-controls, .danmaku-section, .reversal-section, .captions-section { /* Added new sections */
            margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; border-radius: 5px; background-color: #f9f9f9;
        }
        #currentLine { font-size: 1.8em; color: #007bff; margin-bottom: 10px; min-height: 50px; white-space: pre-wrap; }
        #currentPrompt { font-size: 1.2em; color: #28a745; font-style: italic; min-height: 30px; white-space: pre-wrap; }
        button { padding: 10px 15px; margin: 5px 5px 5px 0; border: none; border-radius: 4px; cursor: pointer; background-color: #007bff; color: white; font-size: 1em; }
        button:hover:not(:disabled) { background-color: #0056b3; } /* Add not(:disabled) */
        button:disabled { background-color: #ccc; cursor: not-allowed; }
        .status { color: #dc3545; } .info { color: #17a2b8; } .warning { color: #ffc107; } .success { color: #28a445; } /* Slightly adjusted success color */
        .event-index { font-size: 0.9em; color: #6c757d; text-align: right; }
        
        #script-browser { display: flex; flex-direction: column; gap: 10px; }
        #script-path-breadcrumb { font-weight: bold; color: #555; margin-bottom: 5px; }
        #script-select { width: 100%; min-height: 100px; border: 1px solid #ccc; border-radius: 4px; padding: 5px; box-sizing: border-box; }
        .script-browse-controls { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; }
        .script-browse-controls button { margin-top: 0; margin-bottom: 0; }
    
        .roast-controls div, .danmaku-section div, .reversal-section div, .captions-section div { /* Added new sections divs */
             margin-bottom: 10px; display: flex; flex-wrap: wrap; align-items: center;
        }
        .roast-controls label, .danmaku-section label, .reversal-section label, .captions-section label { /* Added new sections labels */
             margin-right: 10px; 
        }
        .roast-controls input[type="text"], 
        .danmaku-section input[type="text"], 
        .reversal-section input[type="text"], /* Added new sections inputs */
        .captions-section input[type="text"] { /* Added new sections inputs */
             padding: 8px; border: 1px solid #ccc; border-radius: 4px; flex-grow: 1; min-width: 150px; 
        }
        #roastStatus { font-style: italic; color: #555; margin-top: 10px; white-space: pre-wrap; min-height: 20px;}
        
        /* Shared Danmaku Output Area */
        .danmaku-section h4, .reversal-section h4, .captions-section h4 { /* Added new sections h4 */
             margin-top: 15px; margin-bottom: 5px; 
        }
        #danmaku_output_area { 
            margin-top: 10px; 
            white-space: pre-wrap; 
            background-color: #e9ecef; 
            padding: 10px; 
            border-radius: 4px; 
            min-height: 50px; 
            color: #333; 
            max-height: 300px; 
            overflow-y: auto; 
            border: 1px solid #ccc;
            cursor: text; /* Default cursor */
        }
         #danmaku_output_area.copyable {
             cursor: copy;
         }

        /* Adjust search-container to only wrap the first input and its results */
        .danmaku-section .search-container { 
            position: relative; 
            flex-grow: 1; 
            min-width: 150px;
        }
         /* Simple input container for others */
         .input-container {
             flex-grow: 1;
             min-width: 150px;
             /* Add margin/padding if needed to match search-container visual spacing */
         }


        .search-results {
            position: absolute;
            top: 100%; /* Position below the input */
            left: 0;
            right: 0;
            z-index: 10; /* Ensure it's above other content */
            border: 1px solid #ccc;
            background-color: #fff;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            max-height: 150px; /* Limit height */
            overflow-y: auto; /* Add scroll if needed */
            border-radius: 4px;
            margin-top: 2px; /* Small gap between input and dropdown */
        }
        .search-results div {
            padding: 8px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            margin-bottom: 0; /* Override flex margin */
            display: block; /* Make divs block level for full width clicking */
        }
        .search-results div:last-child {
            border-bottom: none;
        }
        .search-results div:hover {
            background-color: #f0f0f0;
        }
        /* Specific input styling - keep flex-grow */
        .danmaku-section input[type="text"], .reversal-section input[type="text"], .captions-section input[type="text"] { flex-grow: 1;} 
        /* Specific button styling - keep margins */
        .danmaku-section div > button, .reversal-section div > button, .captions-section div > button { 
             margin-top: 5px; margin-bottom: 5px;
        }

        #connectionStatusCircle {
             display: inline-block;
             width: 12px;
             height: 12px;
             border-radius: 50%;
             margin-left: 10px;
             vertical-align: middle; /* Align with text */
             background-color: gray; /* Default color */
        }
         #autoSendDanmakuBtn {
            background-color: #28a745; /* Green color */
            color: white;
         }
          #autoSendDanmakuBtn:hover:not(:disabled) {
             background-color: #218838; /* Darker green on hover */
          }

         /* Style for multi-part items in the output area */
         .danmaku-item-part {
             margin-bottom: 10px; /* Space between parts of one item */
             padding: 8px;
             border: 1px dashed #ccc; /* Visual separator */
             border-radius: 4px;
             background-color: #f1f1f1;
             color: #333; /* Ensure text is visible against light background */
         }
         .danmaku-item-part strong {
             color: #000; /* Make labels stand out */
         }


    </style>
</head>
<body>
    <div class="container">
        <h1>ä¸»æ’­æè¯å™¨æ§åˆ¶ç«¯</h1>

        <div class="status-messages">
            <h2>çŠ¶æ€/æ¶ˆæ¯ <span id="connectionStatusCircle"></span></h2>
            <div id="statusMessage" class="status">æœªè¿æ¥åˆ°æœåŠ¡å™¨</div>
        </div>

        <div class="control-panel">
            <h2>è„šæœ¬æ§åˆ¶</h2>
            <div id="script-browser">
                <div id="script-path-breadcrumb">é€‰æ‹©è„šæœ¬æ¥æº</div>
                <div class="script-browse-controls">
                    <button id="script-browse-up-btn" style="display: none;">è¿”å›ä¸Šä¸€çº§</button>
                </div>
                <select id="script-select" size="8">
                    <option value="">-- ç­‰å¾…è¿æ¥ --</option>
                </select>
                <button id="load-selected-script-btn" disabled>åŠ è½½é€‰ä¸­è„šæœ¬</button>
            </div>
        </div>

        <div class="script-info">
            <h3>å½“å‰è„šæœ¬: <span id="scriptName">æœªåŠ è½½</span></h3>
            <h3>è¿›åº¦: <span id="progress">N/A</span></h3>
        </div>

        <div class="current-line-display">
            <h2>å½“å‰å°è¯</h2>
            <div id="currentLine">ç­‰å¾…åŠ è½½è„šæœ¬...</div>
            <h2>æç¤º</h2>
            <div id="currentPrompt">-</div>
            <div class="event-index">äº‹ä»¶: <span id="currentEventIndex">-</span> / <span id="totalEvents">-</span></div>
        </div>
        
        <div class="navigation-controls">
            <h2>å¯¼èˆª</h2>
            <button id="prevEventBtn" disabled>ä¸Šä¸€æ¡ (PgUp)</button>
            <button id="nextEventBtn" disabled>ä¸‹ä¸€æ¡ (Space/PgDn)</button>
        </div>

        <div class="roast-controls">
            <h2>æ€¼é»‘ç²‰æ¨¡å¼ (éšæœºè¯­å½•)</h2>
            <div>
                <label for="roastTargetName">é»‘ç²‰æ˜µç§°:</label>
                <input type="text" id="roastTargetName" placeholder="è¾“å…¥é»‘ç²‰æ˜µç§°">
                <button id="startRoastBtn">å¼€å§‹æ€¼äººåºåˆ— (3æ¡)</button>
            </div>
            <button id="advanceRoastBtn" style="display: none; background-color: #ffc107; color: black;">å‘é€å¼¹å¹•å¹¶çœ‹ä¸‹ä¸€æç¤º (ç©ºæ ¼)</button>
            <div id="roastStatus" style="white-space: pre-wrap; min-height: 20px;"></div>
             <p><small>æ³¨: è¯¥æ¨¡å¼ä¼šéšæœºé€‰å–è¯­å½•ï¼Œå°†è¯­å½•ä¸­**æœ€åä¸€ä¸ªå…¨è§’é€—å·ï¼ˆï¼Œï¼‰å‰çš„éƒ¨åˆ†**ï¼ˆåŒ…å« {} å‚æ•°ï¼‰æ›¿æ¢åä½œä¸ºå¼¹å¹•å‘é€ç»™è§‚ä¼—ï¼Œ**æœ€åä¸€ä¸ªå…¨è§’é€—å·ï¼ˆï¼Œï¼‰åçš„éƒ¨åˆ†**å°†æ˜¾ç¤ºåœ¨â€œå½“å‰å°è¯â€åŒºåŸŸä½œä¸ºæ‚¨çš„æç¤ºã€‚è¯·ç¡®ä¿æ•°æ®åº“ä¸­çš„è¯­å½•ä½¿ç”¨å…¨è§’é€—å·åˆ†éš”ã€‚</small></p>
        </div>

        <!-- è·å–ä¸»æ’­é¢„è®¾å¼¹å¹•åŒºåŸŸ (Welcome/Mock Danmaku) -->
        <div class="danmaku-section">
            <h2>è·å–ä¸»æ’­é¢„è®¾å¼¹å¹• (æ¬¢è¿/åæ§½)</h2>
            <div>
                <label for="streamer_search_input">ä¸»æ’­å:</label>
                 <!-- This search container is for the first input and its results dropdown -->
                <div class="search-container"> 
                    <input type="text" id="streamer_search_input" placeholder="è¾“å…¥ä¸»æ’­åè¿›è¡Œæœç´¢...">
                    <!-- This is the shared search results dropdown -->
                    <div id="streamer_search_results" class="search-results" style="display: none;">
                         <!-- Search results will be populated here -->
                    </div>
                </div>
            </div>
            <div> <!-- Separate div for buttons -->
                 <button id="fetch_welcome_danmaku_btn">è·å–æ¬¢è¿å¼¹å¹•åˆ—è¡¨ (10æ¡)</button>
                 <button id="fetch_roast_danmaku_btn">è·å–åæ§½å¼¹å¹•åˆ—è¡¨ (10æ¡)</button>
                 <!-- New button for auto send (Applies to Welcome/Mock fetched above) -->
                 <button id="autoSendDanmakuBtn">è‡ªåŠ¨å‘é€æ¬¢è¿/åæ§½å¼¹å¹•</button>
            </div>
            
            <h4>å¼¹å¹•ç»“æœ (ç‚¹å‡»å¤åˆ¶):</h4>
            <div id="danmaku_output_area">è¯·å…ˆæœç´¢å¹¶é€‰æ‹©ä¸»æ’­ï¼Œç„¶åè·å–å¼¹å¹•ã€‚</div>
            <p><small>æ³¨: ä»ä¸Šæ–¹åˆ—è¡¨è·å–å¼¹å¹•åï¼Œæ‚¨å¯ä»¥æ‰‹åŠ¨å¤åˆ¶å¼¹å¹•å†…å®¹å¹¶å‘é€åˆ°ç›´æ’­é—´æˆ–ä½¿ç”¨å…¶ä»–å‘é€å¼¹å¹•çš„å·¥å…·ï¼Œæˆ–è€…ç‚¹å‡»â€œè‡ªåŠ¨å‘é€â€æŒ‰é’®é€šè¿‡æœåŠ¡å™¨å‘é€ç»™è§‚ä¼—é¡µé¢ã€‚**è¿™ä¸ªåŒºåŸŸä¹Ÿç”¨äºæ˜¾ç¤ºä¸‹æ–¹æ¨¡å—çš„è·å–ç»“æœã€‚**</small></p>
        </div>
        <!-- åŒºåŸŸç»“æŸ -->

        <!-- NEW: Reversal_Copy Section -->
        <div class="reversal-section">
             <h2>åŠ è½½ä¸»æ’­åè½¬ (Reversal_Copy)</h2>
             <div>
                 <label for="streamer_search_input_reversal">ä¸»æ’­å:</label> 
                 <!-- Use a simple input container -->
                 <div class="input-container"> 
                     <input type="text" id="streamer_search_input_reversal" placeholder="è¾“å…¥ä¸»æ’­å"> 
                 </div>
                 <button id="fetch_reversal_btn">è·å–åè½¬è¯­å½• (10æ¡)</button>
             </div>
             <p><small>æ³¨: è·å–çš„ç»“æœä¼šæ˜¾ç¤ºåœ¨ä¸Šæ–¹çš„â€œå¼¹å¹•ç»“æœâ€åŒºåŸŸã€‚</small></p>
        </div>
        <!-- NEW Section End -->

        <!-- NEW: Social_Topics Section -->
        <div class="captions-section">
             <h2>åŠ è½½ä¸»é¢˜/æ®µå­ (Social_Topics)</h2> 
             <div>
                 <label for="streamer_search_input_captions">ä¸»é¢˜å:</label> 
                 <!-- Use a simple input container -->
                 <div class="input-container"> 
                      <input type="text" id="streamer_search_input_captions" placeholder="è¾“å…¥ä¸»é¢˜å"> 
                 </div>
                 <button id="fetch_captions_btn">è·å–ä¸»é¢˜/æ®µå­æ•°æ® (10æ¡)</button>
             </div>
              <p><small>æ³¨: è·å–çš„ç»“æœä¼šæ˜¾ç¤ºåœ¨ä¸Šæ–¹çš„â€œå¼¹å¹•ç»“æœâ€åŒºåŸŸã€‚</small></p>
        </div>
        <!-- NEW Section End -->


    </div> <!-- end .container -->

    <script>
        // --- Server Ports ---
        // Match these with server.py configuration
        const FLASK_PORT = 5000;
        const WEBSOCKET_PORT = 8765;

        // --- WebSocket Setup ---
        // Use window.location.hostname for flexibility, defaults to 'localhost'
        const wsHost = window.location.hostname || 'localhost'; 
        const wsUrl = `ws://${wsHost}:${WEBSOCKET_PORT}/presenter`;

        // API URL - explicitly construct using http and the determined host and Flask port
        const apiHost = window.location.hostname || 'localhost'; 
        const apiUrl = `http://${apiHost}:${FLASK_PORT}/api`; 


        let websocket;
        let currentBrowsePathContext = null;
        let reconnectTimer = null;
        const reconnectDelay = 3000; // 3 seconds

        // --- DOM Elements ---
        const scriptSelect = document.getElementById('script-select');
        const loadSelectedScriptBtn = document.getElementById('load-selected-script-btn');
        const scriptBrowseUpBtn = document.getElementById('script-browse-up-btn');
        const scriptPathBreadcrumb = document.getElementById('script-path-breadcrumb');
        
        const prevEventBtn = document.getElementById('prevEventBtn');
        const nextEventBtn = document.getElementById('nextEventBtn');
        const scriptNameDisplay = document.getElementById('scriptName');
        const progressDisplay = document.getElementById('progress');
        const currentLineDisplay = document.getElementById('currentLine');
        const currentPromptDisplay = document.getElementById('currentPrompt');
        const statusMessageDisplay = document.getElementById('statusMessage');
        const connectionStatusCircle = document.getElementById('connectionStatusCircle'); // Get the circle element
        const currentEventIndexDisplay = document.getElementById('currentEventIndex');
        const totalEventsDisplay = document.getElementById('totalEvents');

        const roastTargetNameInput = document.getElementById('roastTargetName');
        const startRoastBtn = document.getElementById('startRoastBtn');
        const advanceRoastBtn = document.getElementById('advanceRoastBtn');
        const roastStatusDisplay = document.getElementById('roastStatus');

        // --- DOM Elements for Danmaku Fetch Feature (Welcome/Mock) ---
        const streamerSearchInput = document.getElementById('streamer_search_input');
        const streamerSearchResultsDiv = document.getElementById('streamer_search_results'); // This is for the suggestions dropdown
        const fetchWelcomeBtn = document.getElementById('fetch_welcome_danmaku_btn');
        const fetchRoastBtn = document.getElementById('fetch_roast_danmaku_btn');
        const danmakuOutputArea = document.getElementById('danmaku_output_area');
        const autoSendDanmakuBtn = document.getElementById('autoSendDanmakuBtn');

        // --- NEW DOM Elements for Reversal_Copy and Social_Topics Fetch Feature ---
        // These are now separate input fields with unique IDs
        const streamerSearchInputReversal = document.getElementById('streamer_search_input_reversal'); 
        const streamerSearchInputCaptions = document.getElementById('streamer_search_input_captions'); 
        const fetchReversalBtn = document.getElementById('fetch_reversal_btn'); 
        const fetchCaptionsBtn = document.getElementById('fetch_captions_btn'); 

        // Keep track of the last focused search input to know where to put selected suggestion
        let lastFocusedSearchInput = null;


        let searchDebounceTimer; // Timer for streamer search debounce

        let isInRoastMode = false; // Flag for the anti-fan roast sequence mode

        // --- Utility Functions ---

        // Helper function to send WebSocket messages
        function sendMessage(message) {
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify(message));
                console.log("Presenter: Sent via WebSocket:", message); // Log successful send
            } else {
                console.warn("Presenter: WebSocket is not open. Cannot send message:", message); // Log failure to send
                setStatus("WebSocketæœªè¿æ¥ï¼Œæ— æ³•å‘é€æ¶ˆæ¯ã€‚", "status");
            }
        }


        function setStatus(message, type = "info") {
            statusMessageDisplay.textContent = message;
            statusMessageDisplay.className = type; // 'info', 'status', 'warning', 'success'
             // Update circle color based on type and connection state
             if (websocket && websocket.readyState === WebSocket.OPEN) {
                 connectionStatusCircle.style.backgroundColor = 'green';
             } else if (websocket && websocket.readyState === WebSocket.CONNECTING) {
                 connectionStatusCircle.style.backgroundColor = 'gray';
             } else { // Neither open nor disconnected, likely closing or closed
                 connectionStatusCircle.style.backgroundColor = 'red'; // Assume disconnected if not open/connecting
             }
             // Optional: also use type for color, overriding connection state for errors/warnings
              if (type === "status") { // Often indicates error or disconnected state
                 connectionStatusCircle.style.backgroundColor = 'red';
              } else if (type === "warning") {
                 connectionStatusCircle.style.backgroundColor = 'orange';
              } else if (type === "success" && websocket && websocket.readyState === WebSocket.OPEN) {
                  // Only show green success if actually connected
                  connectionStatusCircle.style.backgroundColor = 'green';
              }
              // For 'info' or other types, the connection state color takes precedence
        }

        function enableScriptNavigation(enabled, currentIndex = -1, totalEvents = 0) {
             // Always disable script navigation if in any special mode (like Roast Mode)
             if (isInRoastMode) {
                  prevEventBtn.disabled = true;
                  nextEventBtn.disabled = true;
                  return;
             }

            if (enabled && totalEvents > 0) {
                // Enable prev if index is 0 or greater (can go back from 0 to -1)
                prevEventBtn.disabled = (currentIndex < 0); 
                nextEventBtn.disabled = (currentIndex >= totalEvents - 1); // Disable next if at last event
            } else {
                prevEventBtn.disabled = true;
                nextEventBtn.disabled = true;
            }
        }

        function updateProgress(currentIndex, totalEvents) {
            if (totalEvents > 0 && currentIndex !== undefined && currentIndex > -1) {
                progressDisplay.textContent = `äº‹ä»¶ ${currentIndex + 1} / ${totalEvents}`;
            } else if (totalEvents > 0 && currentIndex === -1) {
                 progressDisplay.textContent = `å‡†å¤‡å°±ç»ª (å…± ${totalEvents} äº‹ä»¶)`;
            }
            else {
                progressDisplay.textContent = "N/A";
            }
             // Always update navigation button states based on current index and total
             enableScriptNavigation(totalEvents > 0, currentIndex, totalEvents);
        }

        function connect() {
            if (websocket && (websocket.readyState === WebSocket.OPEN || websocket.readyState === WebSocket.CONNECTING)) {
                console.log("Presenter: WebSocket is already connecting or open.");
                return;
            }
             // Clear any pending reconnect timer before attempting a new connection
             if(reconnectTimer) {
                 clearTimeout(reconnectTimer);
                 reconnectTimer = null;
             }

            websocket = new WebSocket(wsUrl);
            console.log("Presenter: Attempting WebSocket connection to:", wsUrl);
            setStatus("-- è¿æ¥ä¸­... --", "info"); // Set status to connecting
            disableAllControls(); // Disable ALL controls initially

            websocket.onopen = () => {
                setStatus("å·²è¿æ¥åˆ°æè¯æœåŠ¡å™¨ã€‚", "success");
                console.log("Presenter: WebSocket connected.");
                // Send registration message first thing on open
                sendMessage({ action: "register", client_type: "presenter" });
                // enableControlsOnConnect() will be called after successful registration message from server
                 // Send pong periodically - handled by server's cleanup now, but client can still send pings proactively
                // sendMessage({ type: "pong" }); // Sent on open, server heartbeats will handle subsequent pings/pongs
            };

            websocket.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    console.log("Presenter: Received from server:", data);

                    // Flag to re-enable auto-send related buttons after processing this message
                    let reEnableAutoSendRelated = false;


                    switch (data.type) {
                        case "registration_success": // Handle successful registration
                            console.log(`Presenter: Successfully registered as ${data.client_type}.`);
                            setStatus(`å·²ä½œä¸º ${data.client_type} æˆåŠŸæ³¨å†Œã€‚`, "success");
                            enableAllControls(); // Enable ALL controls after successful registration (default state)

                            // Server should automatically send script options and current state after registration
                            // These messages will update the UI upon arrival (script_options_update, script_loaded_presenter).

                            break;
                        case "script_options_update":
                            currentBrowsePathContext = data.current_path;
                            scriptPathBreadcrumb.textContent = data.breadcrumb.join(' > ');
                            scriptSelect.innerHTML = '';
                            if (data.options && data.options.length > 0) {
                                data.options.forEach(item => {
                                    const option = document.createElement('option');
                                    option.value = item.path;
                                    option.textContent = item.name;
                                    option.dataset.type = item.type; // 'browse_dir' or 'script_file'
                                    scriptSelect.appendChild(option);
                                });
                            } else {
                                scriptSelect.innerHTML = '<option value="">-- æ­¤ç›®å½•ä¸ºç©º --</option>';
                            }
                            // Show "up" if not in the root directory "."
                            if (currentBrowsePathContext && currentBrowsePathContext !== "." && data.breadcrumb.length > 1) {
                                scriptBrowseUpBtn.style.display = 'inline-block';
                            } else {
                                scriptBrowseUpBtn.style.display = 'none';
                            }
                            // Load button disabled by default, enabled on valid file selection change event
                            loadSelectedScriptBtn.disabled = true; 
                            break;

                         case "script_loaded": 
                             // This type might be sent to all clients including presenter
                             // when a script is loaded. Use script_loaded_presenter for presenter-specific updates.
                             console.log(`Presenter: Script loaded notification: ${data.script_name}`);
                             // Do not update main UI from this, rely on presenter_generic_update or script_loaded_presenter.
                             break;


                        case "script_loaded_presenter": // Initial state after loading script OR on connection/refresh
                             // Exit special modes when a new script is loaded
                             if (isInRoastMode) exitRoastMode(false); // Donm't notify server if just switching script

                            scriptNameDisplay.textContent = data.filename || "æœªçŸ¥è„šæœ¬";
                            totalEventsDisplay.textContent = data.total_events !== undefined ? data.total_events : "-";
                            
                            // Update current line/prompt and index based on the state sent by server
                            currentEventIndexDisplay.textContent = data.event_index !== undefined && data.event_index > -1 ? data.event_index + 1 : "-";
                            currentLineDisplay.textContent = data.current_line || "åŠ è½½ä¸­..."; // Use server's provided line
                            currentPromptDisplay.textContent = data.current_prompt || "-"; // Use server's provided prompt


                            updateProgress(data.event_index, data.total_events);


                            if (data.total_events === 0) {
                                setStatus(`è„šæœ¬ "${data.filename}" åŠ è½½æˆåŠŸï¼Œä½†å†…å®¹ä¸ºç©ºã€‚`, "warning");
                            } else {
                                setStatus(`è„šæœ¬ "${data.filename}" å·²åŠ è½½ï¼Œå…± ${data.total_events} ä¸ªäº‹ä»¶ã€‚`, "success"); // Use success for loaded
                            }

                            // Navigation button state is now handled by updateProgress based on index/total
                            // enableScriptNavigation(true, data.event_index, data.total_events); // Removed - handled by updateProgress
                            break;

                        case "presenter_generic_update": // Handles script display updates (e.g., after navigation)
                            // Only update main display if not in a special sequence mode
                            if (!isInRoastMode) {
                                currentLineDisplay.textContent = data.current_line || ""; // Use current_line from server
                                currentPromptDisplay.textContent = data.current_prompt || "-"; // Use current_prompt from server
                            }
                             // Always update index and total events
                            currentEventIndexDisplay.textContent = data.event_index !== undefined && data.event_index > -1 ? data.event_index + 1 : "-";
                            totalEventsDisplay.textContent = data.total_events !== undefined ? data.total_events : "-";
                            updateProgress(data.event_index, data.total_events);
                             // Navigation button state is now handled by updateProgress
                            // enableScriptNavigation(true, data.event_index, data.total_events); // Removed - handled by updateProgress
                            break;


                        case "audience_display": // Audience updates donm't affect presenter controls
                             // This is mainly for the separate audience display page
                             console.log("Presenter: Received audience display update, ignoring on presenter page:", data);
                             break;

                        case "end_of_script": // Server might send this explicitly, or it's implied by index reaching total-1
                             // The presenter_generic_update case should handle the last event and disable 'next'
                             // If server sends this, it's likely just an info message after the last event.
                             setStatus(data.message || "è„šæœ¬å·²æ’­æ”¾å®Œæ¯•ã€‚", "info");
                             // updateProgress and enableScriptNavigation already handle disabling next button
                            break;

                        case "roast_sequence_ready": // Message type: sequence is fetched, but not started sending yet
                            enterRoastMode('anti_fan');
                             // Update status to indicate readiness
                             roastStatusDisplay.innerHTML = `<strong>æ€¼äººæ¨¡å¼ (ç›®æ ‡: ${escapeHTML(data.target_name || 'N/A')})</strong><br>å·²è·å– ${data.total_roasts} æ¡æ€¼äººè¯­å½•ã€‚<br><em>è¯·ç‚¹å‡» 'å‘é€å¼¹å¹•å¹¶çœ‹ä¸‹ä¸€æç¤º' å¼€å§‹åºåˆ—ã€‚</em>`;
                             roastStatusDisplay.style.display = 'block';
                             
                             // Clear main display areas for roast mode instructions/preview
                             currentLineDisplay.textContent = "ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å‘é€ç¬¬ä¸€æ¡æ€¼äººå¼¹å¹•å¹¶æŸ¥çœ‹æç¤ºã€‚"; // Instruction
                             currentPromptDisplay.textContent = "-"; // Clear prompt
                             
                             advanceRoastBtn.style.display = 'inline-block'; // Show the advance button
                             advanceRoastBtn.disabled = false; // Enable the advance button
                             advanceRoastBtn.textContent = `å‘é€å¼¹å¹•å¹¶çœ‹ä¸‹ä¸€æç¤º (1/${data.total_roasts})`; // Update button text to indicate start

                             setStatus(`æ€¼äººæ¨¡å¼å°±ç»ªï¼Œç›®æ ‡: ${data.target_name}`, "warning");
                            break;

                        case "presenter_roast_update": // Handles displaying *next* prompt after clicking advance
                            // This message indicates the PREVIOUS danmaku was sent (by the server),
                            // and provides the prompt for the CURRENT index.
                            enterRoastMode('anti_fan');
                            
                            // Update main display with the part the presenter should say
                            currentLineDisplay.textContent = data.presenter_line || ""; 
                            
                            // Update prompt/status area with count and raw template for reference
                            // Display raw template in prompt area for verification/debugging
                            roastStatusDisplay.innerHTML = `<strong>æ€¼äººæ¨¡å¼ (ç›®æ ‡: ${escapeHTML(data.target_name || 'N/A')})</strong><br>æç¤º #${data.current_roast_num} / ${data.total_roasts}<br><em>è¯­å½•: ${escapeHTML(data.raw_template || '')}</em>`; 
                            roastStatusDisplay.style.display = 'block'; // Ensure status area is visible
                            currentPromptDisplay.textContent = "ğŸ‘† è¯·çœ‹ä¸Šé¢çš„æç¤º ğŸ‘†"; // Indicate where to look

                            advanceRoastBtn.disabled = false; // Enable button to proceed
                            // Update button text to show progress
                            advanceRoastBtn.textContent = `å‘é€å¼¹å¹•å¹¶çœ‹ä¸‹ä¸€æç¤º (${data.current_roast_num}/${data.total_roasts})`;
                            
                            // Status update might be handled by info/success/error below, or stay as warning


                            break;

                        case "roast_sequence_finished":
                            // Server indicates the roast sequence is complete
                            setStatus(data.message || "æ€¼äººç¯èŠ‚å·²ç»“æŸã€‚", "success"); // Success state for finish
                            roastStatusDisplay.innerHTML = `<em>${escapeHTML(data.message || "åºåˆ—å®Œæˆã€‚")}</em>`; // Escape message HTML
                            exitRoastMode(true); // Exit mode visually and notify server to reset state

                            break;

                         case "presenter_danmaku_sent_confirm":
                             // Confirmation that a manually sent danmaku was broadcast to audience
                             console.log("Presenter: Danmaku sent confirmation:", data.message);
                             // Show a temporary confirmation message - setStatus handles this
                             setStatus(`å¼¹å¹•å·²å‘é€`, "success"); 

                            break;

                        case "pong":
                            // Received pong from server - confirms server is alive and got our connection activity
                            // The server's heartbeat manager tracks pong responses for timeouts.
                            // We donm't need to do anything specific client-side unless implementing a client-side timeout based on pong.
                            // console.log("Presenter: Received pong."); // Too noisy for production
                            break;

                        case "error":
                            setStatus(`é”™è¯¯: ${data.message}`, "status");
                            console.error("Presenter: Server Error:", data);
                            // If error context is roast_mode and we are in it, exit it gracefully
                            if (data.context === "roast_mode" && isInRoastMode) {
                                 roastStatusDisplay.innerHTML = `<em>é”™è¯¯: ${escapeHTML(data.message)}</em>`; // Display error message in roast status
                                 exitRoastMode(true); // Exit mode visually and notify server
                            }
                            // If error context is related to auto_send, re-enable buttons
                            if (data.context && data.context.startsWith("auto_send")) {
                                 reEnableAutoSendRelated = true; // Signal to re-enable after handling
                            }

                            break;

                        case "info":
                            setStatus(`ä¿¡æ¯: ${data.message}`, "info");
                             console.log("Presenter: Server Info:", data);
                             // If this info message is related to auto-send start/progress, no re-enable yet.
                            break;
                        
                        case "success": // Server can send generic success messages
                             setStatus(`æˆåŠŸ: ${data.message}`, "success");
                             console.log("Presenter: Server Success:", data);
                             // If success context is auto_send_finished, re-enable buttons
                             if (data.context === "auto_send_finished") {
                                 reEnableAutoSendRelated = true; // Signal to re-enable after handling
                             }
                            break;

                         case "re_enable_auto_send_buttons": // Explicit message from server to re-enable auto-send related buttons
                             reEnableAutoSendRelated = true; // Signal to re-enable after handling
                             break;
                         
                         // No explicit re_enable message needed for manual fetch buttons
                         // They are re-enabled in the fetchAndDisplayData .finally block


                        default:
                            console.warn("Presenter: Received unknown message type from server:", data.type, data);
                            // setStatus(`æ”¶åˆ°æœªçŸ¥æ¶ˆæ¯ç±»å‹: ${data.type}`, "warning"); // Maybe too noisy
                    }

                     // Check the flag and re-enable buttons if needed after handling the message
                     if(reEnableAutoSendRelated) {
                         // Re-enable all controls that were disabled by starting auto-send
                         enableAllControls(); // Restore default state
                         // Ensure we donm't re-enter roast mode accidentally if coming from a roast task error
                         if (isInRoastMode) {
                             exitRoastMode(false); // Exit visually
                         }
                     }
                     // Manual fetch buttons and related inputs are re-enabled in fetchAndDisplayData's .finally

                } catch (e) {
                    console.error("Presenter: Error parsing or processing WebSocket message:", e, event.data);
                    setStatus("å¤„ç†æœåŠ¡å™¨æ¶ˆæ¯æ—¶å‡ºé”™ã€‚", "status");
                    // On any client-side processing error, try to re-enable all controls
                    enableAllControls();
                    if (isInRoastMode) {
                         exitRoastMode(false); // Exit visually
                    }
                }
            };

            websocket.onclose = (event) => {
                console.log("Presenter: Disconnected from WebSocket.", event.code, event.reason);
                setStatus("å·²æ–­å¼€è¿æ¥ï¼Œæ­£åœ¨å°è¯•è‡ªåŠ¨é‡è¿...", "status");
                disableAllControls(); // Disable ALL controls on disconnect
                // Attempt to reconnect after a delay, only if not already scheduled
                if (!reconnectTimer) {
                    reconnectTimer = setTimeout(connect, reconnectDelay); 
                     console.log(`Presenter: Attempting to reconnect in ${reconnectDelay / 1000} seconds...`);
                }
            };

            websocket.onerror = (error) => {
                console.error("Presenter: WebSocket Error:", error);
                // The 'error' event is often followed by the 'close' event.
                // The 'close' handler is responsible for displaying status and attempting reconnection.
                // setStatus("WebSocketè¿æ¥é”™è¯¯ã€‚", "status"); // This might be redundant if close follows immediately
            };
        }

        function disableAllControls() {
            // Disable all buttons and inputs
             const allButtons = document.querySelectorAll('button');
             allButtons.forEach(button => { button.disabled = true; });

             const allInputs = document.querySelectorAll('input[type="text"], select'); // Also disable select
             allInputs.forEach(input => { input.disabled = true; });

            // Ensure advanceRoastBtn is hidden when disabled
             advanceRoastBtn.style.display = 'none';


            enableScriptNavigation(false); // Explicitly disable script nav

            danmakuOutputArea.textContent = 'ç­‰å¾…è¿æ¥...';
            danmakuOutputArea.classList.remove('copyable'); 

             // Clear roast mode specific UI when connecting
             roastStatusDisplay.textContent = ''; // Clear previous roast status
             roastStatusDisplay.style.display = 'block'; // Ensure it is visible for messages (will be cleared below)


             // Clear display related to script/state
             scriptNameDisplay.textContent = "æœªåŠ è½½";
             progressDisplay.textContent = "N/A";
             currentLineDisplay.textContent = "ç­‰å¾…è¿æ¥...";
             currentPromptDisplay.textContent = "-";
             currentEventIndexDisplay.textContent = "-";
             totalEventsDisplay.textContent = "-";
             
             streamerSearchResultsDiv.style.display = 'none'; // Hide search results dropdown

        }

        function enableAllControls() {
             // Enable all controls to their default state (enabled) after successful connection/registration
             // Note: Individual logic below will then re-disable them based on mode (e.g., Roast Mode) or operations (e.g., Fetching)

             const allButtons = document.querySelectorAll('button');
             allButtons.forEach(button => { 
                 // Special case: advanceRoastBtn is hidden by default, only shown in roast mode
                 if (button.id !== 'advanceRoastBtn') {
                      button.disabled = false; 
                 }
             });

             const allInputs = document.querySelectorAll('input[type="text"], select');
             allInputs.forEach(input => { input.disabled = false; });

             // Script select and browse up buttons enabled/disabled by script_options_update message
             scriptSelect.disabled = false;
             // scriptBrowseUpBtn display/hide handled by script_options_update
             loadSelectedScriptBtn.disabled = true; // Load button is enabled by select change event

             // Script navigation buttons enabled/disabled by script state updates (presenter_generic_update)
             // enableScriptNavigation(false); // Should be enabled/disabled by state updates, not here

            danmakuOutputArea.textContent = 'è¯·å…ˆæœç´¢å¹¶é€‰æ‹©ä¸»æ’­ï¼Œç„¶åè·å–å¼¹å¹•ã€‚'; // Reset prompt
            danmakuOutputArea.classList.remove('copyable');

            // Roast status should be cleared after enabling all controls
            roastStatusDisplay.textContent = "";
            // roastStatusDisplay.style.display = 'none'; // Maybe hide it when not in roast mode? Let's keep it block for messages

             // Ensure roast advance button is hidden in default state
             advanceRoastBtn.style.display = 'none';
             // startRoastBtn is enabled by default in enableAllControls
        }


        function enterRoastMode(modeType) { 
             // Prevent entering if already in roast mode
            if (isInRoastMode) return;

            isInRoastMode = true;
            
            // Disable controls not related to roast mode
            enableScriptNavigation(false); 

             fetchWelcomeBtn.disabled = true; 
             fetchRoastBtn.disabled = true; 
             autoSendDanmakuBtn.disabled = true;
             fetchReversalBtn.disabled = true; 
             fetchCaptionsBtn.disabled = true; 
             streamerSearchInput.disabled = true; // Disable all fetch related inputs
             streamerSearchInputReversal.disabled = true; 
             streamerSearchInputCaptions.disabled = true;

             startRoastBtn.disabled = true; // Disable start button once sequence begins
             roastTargetNameInput.disabled = true; // Disable roast input once sequence begins


             streamerSearchResultsDiv.style.display = 'none'; // Hide search results if open


            // Hide start button, show advance button
            startRoastBtn.style.display = 'none';
            // advanceRoastBtn display/enabled state handled by server messages (roast_sequence_ready, presenter_roast_update)

             roastStatusDisplay.style.display = 'block'; // Ensure status area is visible

             // Clear main line/prompt displays when entering roast mode
             currentLineDisplay.textContent = ""; 
             currentPromptDisplay.textContent = "";

        }


        function exitRoastMode(notifyServer = true) {
            if (!isInRoastMode) return; 
            isInRoastMode = false; 

            // Restore ALL controls to default state (enabled)
            enableAllControls(); 

            // Restore main script navigation based on current state received from server
            // Sending a refresh request ensures UI sync:
            sendMessage({ action: "get_current_event_for_presenter" });


            // Clear roast status area unless it contains an error message
            if (!roastStatusDisplay.textContent.startsWith("é”™è¯¯")) {
                 // Temporarily show "å·²é€€å‡º" message
                 roastStatusDisplay.textContent = "å·²é€€å‡ºæ€¼äººæ¨¡å¼ã€‚";
                 // Clear after a delay, ensuring it's still the same message
                 setTimeout(() => {
                     if (roastStatusDisplay.textContent === "å·²é€€å‡ºæ€¼äººæ¨¡å¼ã€‚") {
                          roastStatusDisplay.textContent = ""; // Clear the status
                          // Decide if you want to hide the block entirely or keep it visible
                          // roastStatusDisplay.style.display = 'none'; // Or hide it
                     }
                 }, 3000);

             }
            // Otherwise, if it was an error message, leave it visible until a new status arrives.


            // Main display will be restored by the presenter_generic_update message

            // Notify server if needed
             if (notifyServer && websocket && websocket.readyState === WebSocket.OPEN) {
                  sendMessage({ action: "exit_roast_mode" });
             } else if (notifyServer) {
                 console.warn("Presenter: Cannot notify server of exit roast mode, WebSocket not open.");
             }
        }


         // Helper to prevent XSS if danmaku contains HTML-like text
         function escapeHTML(str) {
             if (typeof str !== 'string') return str; // Handle non-string input
             const div = document.createElement('div');
             div.appendChild(document.createTextNode(str));
             return div.innerHTML;
         }


        // --- Event Listeners ---

        // Script Browsing/Loading
        scriptSelect.addEventListener('change', () => {
            const selectedOption = scriptSelect.options[scriptSelect.selectedIndex];
            // Enable load button ONLY if a file type is selected and WebSocket is open
            if (selectedOption && selectedOption.dataset.type === 'script_file' && websocket && websocket.readyState === WebSocket.OPEN) {
                loadSelectedScriptBtn.disabled = false;
            } else {
                loadSelectedScriptBtn.disabled = true;
            }
        });

        scriptSelect.addEventListener('dblclick', () => {
            const selectedOption = scriptSelect.options[scriptSelect.selectedIndex];
            // Check if WebSocket is open before sending
             if (websocket && websocket.readyState === WebSocket.OPEN && selectedOption && selectedOption.value) {
                if (selectedOption.dataset.type === 'browse_dir') {
                    sendMessage({ action: "browse_script_path", path: selectedOption.value });
                } else if (selectedOption.dataset.type === 'script_file') {
                    sendMessage({ action: "load_script", filename: selectedOption.value });
                }
             } else if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                 setStatus("WebSocketæœªè¿æ¥ï¼Œæ— æ³•æ‰§è¡Œæ“ä½œã€‚", "status");
             }
             // Do nothing if no valid option selected or double-clicked something else
        });

        scriptBrowseUpBtn.addEventListener('click', () => {
            if (currentBrowsePathContext && websocket && websocket.readyState === WebSocket.OPEN) {
                // Calculate parent path relative to BASE_DIR (using Path object logic server-side)
                // Client sends the current relative path, server computes the parent
                sendMessage({ action: "browse_script_path", path: currentBrowsePathContext + "/.." }); // Append /.. for server to resolve
            } else if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                 setStatus("WebSocketæœªè¿æ¥ï¼Œæ— æ³•æ‰§è¡Œæ“ä½œã€‚", "status");
            }
        });

        loadSelectedScriptBtn.addEventListener('click', () => {
            const selectedOption = scriptSelect.options[scriptSelect.selectedIndex];
            // Check if a script file is selected and WebSocket is open
            if (selectedOption && selectedOption.dataset.type === 'script_file' && websocket && websocket.readyState === WebSocket.OPEN) {
                sendMessage({ action: "load_script", filename: selectedOption.value });
            } else if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                 setStatus("WebSocketæœªè¿æ¥ï¼Œæ— æ³•åŠ è½½è„šæœ¬ã€‚", "status");
            }
        });

        // Script Navigation
        prevEventBtn.addEventListener('click', () => {
             // Check if button is enabled (handled by enableScriptNavigation) and WebSocket is open
             if (!prevEventBtn.disabled && websocket && websocket.readyState === WebSocket.OPEN) {
                 sendMessage({ action: "prev_event" });
             } else if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                 setStatus("WebSocketæœªè¿æ¥ï¼Œæ— æ³•æ‰§è¡Œæ“ä½œã€‚", "status");
             }
        });
        nextEventBtn.addEventListener('click', () => {
            // Check if button is enabled (handled by enableScriptNavigation) and WebSocket is open
             if (!nextEventBtn.disabled && websocket && websocket.readyState !== WebSocket.OPEN) {
                 sendMessage({ action: "next_event" });
             } else if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                 setStatus("WebSocketæœªè¿æ¥ï¼Œæ— æ³•æ‰§è¡Œæ“ä½œã€‚", "status");
             }
        });

        // Roast Mode Controls (Anti-Fan)
        startRoastBtn.addEventListener('click', () => {
        const targetName = roastTargetNameInput.value.trim();
        if (!targetName) {
            roastStatusDisplay.textContent = "è¯·è¾“å…¥é»‘ç²‰æ˜µç§°ã€‚";
            return;
        }
        if (websocket && websocket.readyState === WebSocket.OPEN) {
            console.log(`Presenter: startRoastBtn clicked for target "${targetName}", starting roast mode...`);
            const targetName = roastTargetNameInput.value.trim();
            if (!targetName) {
                roastStatusDisplay.textContent = "è¯·è¾“å…¥é»‘ç²‰æ˜µç§°ã€‚";
                return;
            }
             // Check if WebSocket is open (Required for this feature's sequence control)
             if (websocket && websocket.readyState === WebSocket.OPEN) {
                 // Disable controls not related to roast mode or sequence
                 enableScriptNavigation(false); 
                 fetchWelcomeBtn.disabled = true; 
                 fetchRoastBtn.disabled = true; 
                 autoSendDanmakuBtn.disabled = true; 
                 fetchReversalBtn.disabled = true; 
                 fetchCaptionsBtn.disabled = true; 
                 streamerSearchInput.disabled = true; 
                 streamerSearchInputReversal.disabled = true; 
                 streamerSearchInputCaptions.disabled = true;
                 
                 // Disable roast start button and input while fetching sequence
                 startRoastBtn.disabled = true;
                 roastTargetNameInput.disabled = true;


                 roastStatusDisplay.textContent = `æ­£åœ¨ä¸º "${targetName}" è·å–æ€¼äººè¯­å½•...`;
                 roastStatusDisplay.style.display = 'block'; // Ensure status area is visible
                 
                 // Send action to get the sequence. Server will respond with roast_sequence_ready or error.
                 sendMessage({ action: "get_roast_sequence", target_name: targetName });

                 // The advance button will be enabled when roast_sequence_ready is received.

             } else {
                 setStatus("WebSocketæœªè¿æ¥ï¼Œæ— æ³•å¼€å§‹æ€¼äººæ¨¡å¼ã€‚", "status");
                 roastStatusDisplay.textContent = "WebSocketæœªè¿æ¥ï¼Œæ€¼äººæ¨¡å¼ä¸å¯ç”¨ã€‚";
                  roastStatusDisplay.style.display = 'block'; // Ensure status area is visible
             }
        });

        advanceRoastBtn.addEventListener('click', () => {
            // Check if in roast mode, button is enabled, and WebSocket is open
            if (!isInRoastMode || advanceRoastBtn.disabled || !websocket || websocket.readyState !== WebSocket.OPEN) {
                if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                    setStatus("WebSocketæœªè¿æ¥ï¼Œæ— æ³•æ‰§è¡Œæ“ä½œã€‚", "status");
                }
                 return;
            }

            // In the anti-fan roast mode, clicking 'advance' means trigger the server to:
            // 1. Send the danmaku for the *current* prompt (at the new index) to audience.
            // 2. Prepare the *next* prompt's presenter line and update the UI.
            
            // Before sending, ensure the button is disabled to prevent rapid clicks
            advanceRoastBtn.disabled = true; 

            // Send action to server to advance the sequence.
            // The server will handle sending the danmaku and preparing the next prompt.
            sendMessage({ action: "advance_roast" }); 
            
            // The button will be re-enabled when the NEXT prompt arrives via WebSocket ("presenter_roast_update")
            // or when the sequence finishes ("roast_sequence_finished").

        });

        // Global Keyboard Shortcuts
        document.addEventListener('keydown', (event) => {
            // Prevent interference with input fields
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA' || event.target.tagName === 'SELECT') {
                return;
            }

            // Only process keyboard shortcuts if WebSocket is open and registered
             if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                 // Optionally give feedback
                 // console.warn("Presenter: WebSocket not connected, keyboard shortcuts disabled.");
                 return;
             }


            if (isInRoastMode) {
                // In roast mode, Space/PgDn triggers advanceRoastBtn
                if (event.key === ' ' || event.key === 'PageDown') {
                    event.preventDefault(); // Prevent scrolling
                    if (!advanceRoastBtn.disabled && advanceRoastBtn.style.display !== 'none') {
                         // Check if button is visible and enabled
                        advanceRoastBtn.click();
                    } else {
                         console.log("Presenter: Roast advance button not active or disabled.");
                    }
                } else if (event.key === 'PageUp') { // Maybe PgUp should exit roast mode too?
                     // Decide if PgUp should exit or do nothing in roast mode
                     console.log("Presenter: PgUp pressed in Roast Mode. No action defined.");
                }
                else if (event.key === 'Escape') {
                    event.preventDefault(); // Prevent default Escape behavior if needed
                    // Exit any active sequence mode
                    if (isInRoastMode) {
                        exitRoastMode(true); // Allow server notification to reset state
                    }
                }
            } else {
                // Normal script navigation
                if (event.key === ' ' || event.key === 'PageDown') {
                    event.preventDefault(); // Prevent scrolling
                    // nextEventBtn state is managed by updateProgress/enableScriptNavigation
                    if (!nextEventBtn.disabled) {
                        nextEventBtn.click();
                    }
                } else if (event.key === 'PageUp') {
                    event.preventDefault(); // Prevent scrolling
                     // prevEventBtn state is managed by updateProgress/enableScriptNavigation
                    if (!prevEventBtn.disabled) {
                        prevEventBtn.click();
                    }
                }
            }
        });


        // --- New Feature: Streamer Danmaku Search and Fetch (Uses HTTP API and WebSocket) ---

        // --- Search Suggestion Logic (Triggered by any search input, suggestions under the first one) ---

        // Add focus event listeners to track which search input is active
        streamerSearchInput.addEventListener('focus', (event) => { lastFocusedSearchInput = event.target; });
        streamerSearchInputReversal.addEventListener('focus', (event) => { lastFocusedSearchInput = event.target; });
        streamerSearchInputCaptions.addEventListener('focus', (event) => { lastFocusedSearchInput = event.target; });


        // Add input event listeners to ALL search inputs to trigger debounce
        streamerSearchInput.addEventListener('input', (event) => { triggerSearchDebounce(event.target); });
        streamerSearchInputReversal.addEventListener('input', (event) => { triggerSearchDebounce(event.target); });
         streamerSearchInputCaptions.addEventListener('input', (event) => { triggerSearchDebounce(event.target); });


        function triggerSearchDebounce(inputElement) {
            clearTimeout(searchDebounceTimer);
            const searchTerm = inputElement.value.trim();
            // Only trigger search if there's a term to search for and WebSocket is open
            // Adding WebSocket check here because API search depends on DB connection which is checked on WS registration
            if (searchTerm.length > 0 && websocket && websocket.readyState === WebSocket.OPEN) {
                searchDebounceTimer = setTimeout(() => {
                    fetchStreamerSuggestions(searchTerm);
                }, 300); // 300ms debounce delay
            } else {
                // Hide results immediately if input is cleared or WebSocket is not open
                streamerSearchResultsDiv.style.display = 'none';
                streamerSearchResultsDiv.innerHTML = '';
                 if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                      console.warn("Presenter: WebSocket not connected. Search suggestions disabled.");
                 }
            }
        }


        function fetchStreamerSuggestions(term) {
             // This uses HTTP fetch API to the Flask server. It should work
             // as long as the Flask API server is running on FLASK_PORT,
             // and the HTML page is accessed via http://localhost:5000 or http://server_ip:5000
             // Using apiUrl correctly builds the URL.

            console.log(`Presenter: Fetching streamer suggestions for term: "${term}" from ${apiUrl}/search_streamers`); // Log the URL
            fetch(`${apiUrl}/search_streamers?term=${encodeURIComponent(term)}`)
                .then(response => {
                     console.log("Presenter: Search streamers API response status:", response.status);
                     if (!response.ok) {
                         // Handle non-200 responses like 400, 500 from server
                         // The .json() parsing below will handle the structured error if provided
                         // If server returns HTML (like 500 error page), response.json() will throw SyntaxError
                         // We catch this SyntaxError in the next .catch block
                         return response.json().then(data => {
                            // If server returned JSON error, throw a specific Error
                            throw new Error(`HTTP error! status: ${response.status}, message: ${data.error || 'æœªçŸ¥é”™è¯¯'}`);
                         });
                     }
                    return response.json(); // This is where SyntaxError for non-JSON happens if server returns HTML
                })
                .then(data => {
                    console.log("Presenter: Search streamers API response data:", data);
                    streamerSearchResultsDiv.innerHTML = ''; // Clear previous results
                    // Assume data is an array of strings if no error in previous step
                    if (data && Array.isArray(data) && data.length > 0) {
                        data.forEach(name => {
                            const div = document.createElement('div');
                            div.textContent = name;
                            div.addEventListener('click', () => {
                                // When a suggestion is clicked, put the value into the LAST FOCUSED input field
                                if (lastFocusedSearchInput) {
                                     lastFocusedSearchInput.value = name;
                                     // After selecting, blur the input to dismiss mobile keyboards and clear focus state visually
                                     lastFocusedSearchInput.blur(); 
                                } else {
                                     // Fallback to the first input if focus tracking failed (unlikely with focus listeners)
                                     streamerSearchInput.value = name;
                                     streamerSearchInput.blur(); 
                                }

                                // Hide and clear results
                                streamerSearchResultsDiv.style.display = 'none';
                                streamerSearchResultsDiv.innerHTML = ''; 
                            });
                            streamerSearchResultsDiv.appendChild(div);
                        });
                        streamerSearchResultsDiv.style.display = 'block'; // Show dropdown
                    } else {
                        // No results found or empty array
                        const noResultDiv = document.createElement('div');
                        noResultDiv.textContent = "æœªæ‰¾åˆ°åŒ¹é…çš„ä¸»æ’­å";
                        noResultDiv.style.color = '#6c757d';
                        noResultDiv.style.padding = '8px'; // Add padding to look like an option
                        streamerSearchResultsDiv.appendChild(noResultDiv);
                        streamerSearchResultsDiv.style.display = 'block'; // Show "no result" message
                    }
                })
                .catch(error => {
                    console.error('Presenter: Error fetching streamer suggestions:', error);
                     // Display a network error message near the search box
                    streamerSearchResultsDiv.innerHTML = ''; // Clear previous results
                    const errorDiv = document.createElement('div');
                    // Check if the error is the JSON parsing error
                    if (error instanceof SyntaxError && error.message.includes("Unexpected token '<'")) {
                         errorDiv.textContent = "æœç´¢å¤±è´¥: æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ (éJSONå“åº”)ã€‚è¯·æ£€æŸ¥æœåŠ¡å™¨ç»ˆç«¯æ—¥å¿—ã€‚";
                    } else {
                         errorDiv.textContent = `æœç´¢å¤±è´¥: ${error.message}`; // Display specific error message
                    }
                    errorDiv.style.color = 'red';
                     errorDiv.style.padding = '8px';
                    streamerSearchResultsDiv.appendChild(errorDiv);
                    streamerSearchResultsDiv.style.display = 'block';
                     // Optionally clear the error message after a delay
                     setTimeout(() => { streamerSearchResultsDiv.style.display = 'none'; }, 5000); // Hide after 5 seconds
                });
        }

        // Hide search results when clicking outside the input or results area
        document.addEventListener('click', function(event) {
            // Check if the click was inside the main search container (where the dropdown appears)
            const searchContainerDiv = streamerSearchInput.closest('.search-container'); // Get the parent container of the first input

            // Also check if the click was on any of the search input elements themselves
            const isClickOnInput = event.target === streamerSearchInput || event.target === streamerSearchInputReversal || event.target === streamerSearchInputCaptions;
             // Also check if the click was inside the search results dropdown itself
            const isClickInsideResults = streamerSearchResultsDiv.contains(event.target);


            // Hide if clicked outside the main search container AND not directly on any search input AND not inside the results dropdown
            if (searchContainerDiv && !searchContainerDiv.contains(event.target) && !isClickOnInput && !isClickInsideResults) {
                 streamerSearchResultsDiv.style.display = 'none';
             }
             // If the click was inside the main search container (including the dropdown), the suggestion click listener handles it.
             // If the click was on one of the other search inputs, the focus listener updates lastFocusedSearchInput, and the input listener triggers a *new* search.
        });


        // Fetch and display data lists from API (for manual copy) - MODIFIED to handle different input elements
        function fetchAndDisplayData(type, inputElement) { // Accept inputElement as argument
            const streamerName = inputElement.value.trim(); // Get value from the specific input element
            if (!streamerName) {
                danmakuOutputArea.innerHTML = 'è¯·è¾“å…¥å¹¶é€‰æ‹©ä¸€ä¸ªä¸»æ’­å/ä¸»é¢˜åã€‚'; // Use innerHTML for consistency
                danmakuOutputArea.classList.remove('copyable');
                return;
            }
            
            console.log(`Presenter: Attempting to fetch ${type} data for streamer/topic: "${streamerName}"`); 
            danmakuOutputArea.innerHTML = 'æ­£åœ¨åŠ è½½æ•°æ®...'; // Use innerHTML to clear previous formatted content
            danmakuOutputArea.classList.remove('copyable');

            let endpoint = '';
            let context = ''; // For logging/status
            let displayTitle = ''; // Title for status and messages

            // Determine the API endpoint and display title based on the requested type
            if (type === 'welcome' || type === 'roast') {
                 endpoint = `${apiUrl}/streamer_danmaku?name=${encodeURIComponent(streamerName)}&type=${encodeURIComponent(type)}`;
                 context = 'fetch_danmaku';
                 displayTitle = type === 'welcome' ? 'æ¬¢è¿å¼¹å¹•' : 'åæ§½å¼¹å¹•';
            } else if (type === 'reversal') {
                 endpoint = `${apiUrl}/streamer_reversal_copy?name=${encodeURIComponent(streamerName)}`;
                 context = 'fetch_reversal';
                 displayTitle = 'åè½¬è¯­å½•';
            } else if (type === 'captions') { // Now handles Social_Topics
                 endpoint = `${apiUrl}/streamer_social_topics?name=${encodeURIComponent(streamerName)}`; // Use Social_Topics API
                 context = 'fetch_captions'; 
                 displayTitle = 'ä¸»é¢˜/æ®µå­'; 
            } else {
                 console.error(`Presenter: Invalid fetch type: ${type}`);
                 setStatus("å†…éƒ¨é”™è¯¯: æ— æ•ˆçš„è·å–ç±»å‹ã€‚", "status");
                 danmakuOutputArea.innerHTML = "å‘ç”Ÿå†…éƒ¨é”™è¯¯ã€‚";
                 return;
            }

            // Disable ALL manual fetch buttons and auto-send/roast buttons during ANY manual fetch
            // This simplifies button state management during fetching.
             fetchWelcomeBtn.disabled = true;
             fetchRoastBtn.disabled = true;
             fetchReversalBtn.disabled = true;
             fetchCaptionsBtn.disabled = true;
             autoSendDanmakuBtn.disabled = true; 
             startRoastBtn.disabled = true; 
             roastTargetNameInput.disabled = true; // Disable roast input too


            fetch(endpoint)
                .then(response => {
                     console.log(`Presenter: ${context} API response status:`, response.status);
                     if (!response.ok) {
                         // Handle non-200 responses
                         // If server returns HTML (like 500 error page), response.json() will throw SyntaxError
                         // We catch this SyntaxError in the next .catch block
                          return response.json().then(data => {
                             // If server returned JSON error, throw a specific Error
                            throw new Error(`HTTP error! status: ${response.status}, message: ${data.error || 'æœªçŸ¥é”™è¯¯'}`);
                          });
                     }
                    return response.json(); // This is where SyntaxError for non-JSON happens
                })
                .then(data => {
                    console.log(`Presenter: ${context} API response data:`, data);
                    
                    danmakuOutputArea.innerHTML = ''; // Clear previous results
                    
                    if (data && Array.isArray(data) && data.length > 0) {
                         let htmlContent = '';
                         data.forEach((item, index) => {
                             // Handle different data structures based on type
                             if (type === 'welcome' || type === 'roast' || type === 'captions') { // Welcome/Mock/Social_Topics return list of strings
                                 // Expected: list of strings
                                  // Add leading number and escape HTML
                                  // Wrap simple text in a div for easier copy target later
                                  htmlContent += `<div>${index + 1}. ${escapeHTML(item)}</div>`; 
                             } else if (type === 'reversal') { // Expected: list of dicts {"danmaku_part": "...", "read_part": "..."}
                                 if (typeof item === 'object' && item !== null) {
                                     const danmaku = item.danmaku_part || '';
                                     const read = item.read_part || '';
                                     htmlContent += `<div>${index + 1}.</div>`; // Add number outside the parts div for Reversal
                                     // Wrap danmaku and prompt parts in their own divs with specific classes
                                     htmlContent += `<div class="danmaku-item-part"><strong>å¼¹å¹•:</strong> ${escapeHTML(danmaku)}</div>`;
                                     htmlContent += `<div class="danmaku-item-part"><strong>æç¤º:</strong> ${escapeHTML(read)}</div>`;
                                 } else {
                                      console.warn(`Presenter: Received non-object item in ${type} data:`, item);
                                      htmlContent += `<div>${index + 1}. [æ•°æ®æ ¼å¼é”™è¯¯]</div>`; // Show error for the item
                                 }
                             }
                             htmlContent += `\n`; // Add newline after each item/group of parts for pre-wrap spacing
                         });
                         
                         danmakuOutputArea.innerHTML = htmlContent; // Set the formatted HTML
                         danmakuOutputArea.classList.add('copyable'); // Make the container copyable
                         setStatus(`å·²è·å– ${data.length} æ¡${displayTitle}ã€‚ç‚¹å‡»æ–‡æœ¬å¤åˆ¶å†…å®¹ã€‚`, "info"); // Updated status message
                    } else {
                        // No results found or empty array from server
                        danmakuOutputArea.innerHTML = `æœªæ‰¾åˆ°é’ˆå¯¹ "${streamerName}" çš„${displayTitle}ã€‚`; // Use innerHTML
                         danmakuOutputArea.classList.remove('copyable');
                         setStatus(`æœªæ‰¾åˆ°æ•°æ®: ${streamerName} çš„${displayTitle}ã€‚`, "warning");
                    }
                })
                .catch(error => {
                    console.error(`Presenter: Error fetching ${type} data:`, error);
                    // Check if the error is the JSON parsing error
                    if (error instanceof SyntaxError && error.message.includes("Unexpected token '<'")) {
                         danmakuOutputArea.innerHTML = `è·å–${displayTitle}å¤±è´¥: æœåŠ¡å™¨å†…éƒ¨é”™è¯¯ (éJSONå“åº”)ã€‚è¯·æ£€æŸ¥æœåŠ¡å™¨ç»ˆç«¯æ—¥å¿—ã€‚`; // Use innerHTML
                    } else {
                         danmakuOutputArea.innerHTML = `è·å–${displayTitle}å¤±è´¥: ${escapeHTML(error.message)}`; // Display specific error message, escape potential HTML in message
                    }
                     danmakuOutputArea.classList.remove('copyable');
                     setStatus(`è·å–${displayTitle}å¤±è´¥: ${error.message}`, "status");
                })
                .finally(() => {
                     // Re-enable manual fetch buttons and roast start button after ANY manual fetch process finishes (success or error)
                     // Auto-send button state is handled by server messages if starting auto-send disabled it.
                     fetchWelcomeBtn.disabled = false;
                     fetchRoastBtn.disabled = false;
                     fetchReversalBtn.disabled = false;
                     fetchCaptionsBtn.disabled = false;
                     startRoastBtn.disabled = false; // Re-enable roast start button
                     roastTargetNameInput.disabled = false; // Re-enable roast input

                     // autoSendDanmakuBtn state is ONLY managed by server messages (auto_send_danmaku starts it, re_enable_auto_send_buttons re-enables it)
                     // But we should also re-enable it here if it wasn't disabled by starting auto-send
                      if (!autoSendDanmakuBtn.disabled) { // Check if it was already disabled by starting auto-send
                          autoSendDanmakuBtn.disabled = false; // Re-enable it if it wasn't
                      }
                      // Re-enable search inputs as well
                      streamerSearchInput.disabled = false;
                      streamerSearchInputReversal.disabled = false; 
                      streamerSearchInputCaptions.disabled = false;

                });
        }

        // Add click listeners to the displayed danmaku items for easy copying
        // Use event delegation on the container #danmaku_output_area
         danmakuOutputArea.addEventListener('click', function(event) {
            const clickedElement = event.target;
             // Check if the container is marked as copyable
            if (danmakuOutputArea.classList.contains('copyable')) {
                let textToCopy = '';
                let elementToHighlight = null; // Keep track of the element to highlight

                // If clicked directly on .danmaku-item-part, get its text content and mark it for highlight
                if (clickedElement.classList.contains('danmaku-item-part')) {
                    const labelSpan = clickedElement.querySelector('strong');
                    if (labelSpan) {
                         // Get text content after the label
                         textToCopy = clickedElement.textContent.substring(labelSpan.textContent.length).trim();
                    } else {
                         textToCopy = clickedElement.textContent.trim(); // Fallback if strong tag not found
                    }
                    elementToHighlight = clickedElement; // Highlight the part div

                } else if (clickedElement.parentElement && clickedElement.parentElement.classList.contains('danmaku-item-part')) {
                     // If clicked on a child element inside .danmaku-item-part (e.g. strong tag)
                     const danmakuPartElement = clickedElement.parentElement;
                     const labelSpan = danmakuPartElement.querySelector('strong');
                     if (labelSpan) {
                          // Get text content after the label
                          textToCopy = danmakuPartElement.textContent.substring(labelSpan.textContent.length).trim();
                     } else {
                          textToCopy = danmakuPartElement.textContent.trim();
                     }
                     elementToHighlight = danmakuPartElement; // Highlight the parent part div


                } else if (danmakuOutputArea.contains(clickedElement) && clickedElement !== danmakuOutputArea) {
                    // If clicked on text directly within danmaku_output_area (likely for Welcome/Mock or Social_Topics strings)
                    // Need to find the specific div containing the text that was clicked
                    let targetTextDiv = clickedElement;
                     // Traverse up to find the containing div or stop at the main container
                     while (targetTextDiv && targetTextDiv.tagName !== 'DIV' && targetTextDiv !== danmakuOutputArea) {
                         targetTextDiv = targetTextDiv.parentElement;
                     }

                    if (targetTextDiv && targetTextDiv !== danmakuOutputArea) { // Ensure we found a div and it's not the main container
                         // Check if it is a simple text line (like Welcome/Mock/Social_Topics)
                         if (!targetTextDiv.classList.contains('danmaku-item-part')) {
                             const lineText = targetTextDiv.textContent;
                             // Use regex to find the text content after the leading number and dot
                             const match = lineText.match(/^\d+\.\s*(.*)/);
                             textToCopy = match ? match[1].trim() : lineText.trim(); // Copy text after number. or the whole line
                             elementToHighlight = targetTextDiv; // Highlight the div element
                         }
                         // If it *is* a danmaku-item-part, the first two checks handle it.
                         
                    } else if (clickedElement === danmakuOutputArea) {
                         // Clicked on the container itself, do nothing for copy
                         textToCopy = ''; // No text to copy from container background
                    } else {
                         // Fallback: Get text content of the clicked element if it is not the container
                         // This case might happen if clicking directly on a text node inside a div without specific class
                         textToCopy = clickedElement.textContent ? clickedElement.textContent.trim() : '';
                         // No easy way to highlight. elementToHighlight remains null or could be set to danmakuOutputArea for broad feedback.
                    }


                }


                if (textToCopy) {
                     // Prevent copying the placeholder or initial text
                     if (textToCopy === 'è¯·å…ˆæœç´¢å¹¶é€‰æ‹©ä¸»æ’­ï¼Œç„¶åè·å–å¼¹å¹•ã€‚' || textToCopy === 'æ­£åœ¨åŠ è½½æ•°æ®...' || textToCopy === 'è¿æ¥å·²æ–­å¼€ã€‚') { // Updated placeholder text check
                          console.log("Presenter: Skipping copy of placeholder/status text.");
                          return; // Do not copy placeholder text
                     }

                     navigator.clipboard.writeText(textToCopy).then(() => {
                         console.log('Presenter: Copied:', textToCopy);
                         // Show temporary visual feedback on the element itself if we have one to highlight
                        if (elementToHighlight && elementToHighlight.style) {
                            const originalBackground = elementToHighlight.style.backgroundColor;
                            const originalColor = elementToHighlight.style.color;
                             // Also save original border/box-shadow if you added styles there
                             const originalBorder = elementToHighlight.style.border;
                             const originalBoxShadow = elementToHighlight.style.boxShadow;

                            elementToHighlight.style.backgroundColor = '#d4edda'; // Light green background
                            elementToHighlight.style.color = '#155724'; // Darker green text


                            setTimeout(() => {
                                elementToHighlight.style.backgroundColor = originalBackground; // Restore background
                                elementToHighlight.style.color = originalColor; // Restore color
                                // Restore border/box-shadow
                                elementToHighlight.style.border = originalBorder;
                                elementToHighlight.style.boxShadow = originalBoxShadow;

                            }, 500); // Change back after 0.5 seconds
                        }


                         setStatus("å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼", "success"); // Updated status message
                         // Clear status message after a few seconds if it is still the copy success message
                         const copySuccessMessage = "å†…å®¹å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼"; // Updated message to match
                         setTimeout(() => {
                             if (statusMessageDisplay.textContent === copySuccessMessage) {
                                 // Restore connection status if no other message arrived
                                  if (websocket && websocket.readyState === WebSocket.OPEN) {
                                       setStatus("å·²è¿æ¥åˆ°æè¯æœåŠ¡å™¨ã€‚", "success");
                                  } else if (websocket && websocket.readyState === WebSocket.CONNECTING) {
                                       setStatus("æ­£åœ¨å°è¯•è¿æ¥...", "info");
                                  } else {
                                       setStatus("å·²æ–­å¼€è¿æ¥ï¼Œæ­£åœ¨å°è¯•è‡ªåŠ¨é‡è¿...", "status");
                                  }
                             }
                         }, 3000); // Clear after 3 seconds

                     }).catch(err => {
                         console.error('Presenter: Failed to copy text: ', err);
                         setStatus("å¤åˆ¶å¤±è´¥ã€‚", "status"); // Updated status message
                     });
                 } else {
                      console.log("Presenter: Clicked element has no text to copy or extract.");
                      // Optionally provide user feedback that there was nothing to copy
                      // setStatus("æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹ã€‚", "warning"); // Uncomment for feedback
                 }
             }
        });

        // --- Add listeners for the fetch buttons, passing the correct input element ---
        fetchWelcomeBtn.addEventListener('click', () => {
            fetchAndDisplayData('welcome', streamerSearchInput); // Pass streamerSearchInput
        });

        fetchRoastBtn.addEventListener('click', () => {
            fetchAndDisplayData('roast', streamerSearchInput); // Pass streamerSearchInput
        });

        // NEW: Add listeners for the new fetch buttons, passing their specific input elements
        fetchReversalBtn.addEventListener('click', () => {
            fetchAndDisplayData('reversal', streamerSearchInputReversal); // Pass streamerSearchInputReversal
        });
         fetchCaptionsBtn.addEventListener('click', () => {
            fetchAndDisplayData('captions', streamerSearchInputCaptions); // Pass streamerSearchInputCaptions
        });


        // New button for auto send functionality
        // This button ONLY sends Welcome/Mock danmaku, so it should still use the FIRST input value
        autoSendDanmakuBtn.addEventListener('click', () => {
             const streamerName = streamerSearchInput.value.trim(); // Use the main search input value for auto-send
             if (!streamerName) {
                 setStatus('è¯·è¾“å…¥å¹¶é€‰æ‹©ä¸€ä¸ªä¸»æ’­åæ‰èƒ½è‡ªåŠ¨å‘é€å¼¹å¹•ã€‚', 'warning');
                 return;
             }

             // Check if WebSocket is open
             if (!websocket || websocket.readyState !== WebSocket.OPEN) {
                 setStatus("WebSocketæœªè¿æ¥ï¼Œæ— æ³•è‡ªåŠ¨å‘é€å¼¹å¹•ã€‚", "status");
                 return;
             }
             
             // Disable buttons during sending to prevent interference
             autoSendDanmakuBtn.disabled = true;
             // Disable manual fetch and roast start buttons as auto send runs
             fetchWelcomeBtn.disabled = true; 
             fetchRoastBtn.disabled = true;
             fetchReversalBtn.disabled = true; // Disable new fetch buttons
             fetchCaptionsBtn.disabled = true; // Disable new fetch buttons
             startRoastBtn.disabled = true; 
             roastTargetNameInput.disabled = true; 
             
             // Disable individual search inputs
             streamerSearchInput.disabled = true; // Also disable the input fields themselves
             streamerSearchInputReversal.disabled = true; 
             streamerSearchInputCaptions.disabled = true;


             setStatus(`æ­£åœ¨å‡†å¤‡è‡ªåŠ¨å‘é€ ${streamerName} çš„æ¬¢è¿/åæ§½å¼¹å¹•...`, "info"); // Specify which types are sent


             // Send the action to the server via WebSocket
             sendMessage({ action: "auto_send_danmaku", streamer_name: streamerName });

             // Server will handle fetching and sending.
             // Server will send back status/info/success/error messages during the process.
             // The buttons and inputs will be re-enabled when the task finishes (server sends success/error with context or re_enable_auto_send_buttons message).

        });


        // --- Initial Connection ---
        // Wait for the DOM to be fully loaded before attempting to connect
        document.addEventListener('DOMContentLoaded', (event) => {
            console.log('Presenter: DOM fully loaded. Attempting WebSocket connection.');
            connect();
        });


    </script>
</body>
</html>
